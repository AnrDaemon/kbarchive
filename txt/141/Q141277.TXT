DOCUMENT:Q141277  29-APR-2002  [visualc]
TITLE   :HOWTO: Override an Interface in an MFC Application
PRODUCT :Microsoft C Compiler
PROD/VER::2.0,2.1,2.2,4.0,5.0,6.0
OPER/SYS:
KEYWORDS:kbole kbActiveX kbCOMt kbCtrl kbMFC kbVC200 kbVC400 kbVC500 kbVC600 kbGrpDSMFCATL kbArc

======================================================================
-------------------------------------------------------------------------------
The information in this article applies to:

 - The Microsoft Foundation Classes (MFC), used with:
    - Microsoft Visual C++, 32-bit Editions, versions 2.0, 2.1, 2.2, 4.0 
    - Microsoft Visual C++, 32-bit Enterprise Edition, versions 5.0, 6.0 
    - Microsoft Visual C++, 32-bit Professional Edition, versions 5.0, 6.0 
    - Microsoft Visual C++, 32-bit Learning Edition, version 6.0 
    - Microsoft Visual C++.NET (2002) 
-------------------------------------------------------------------------------

NOTE: Microsoft Visual C++ NET (2002) supported both the managed code model that is provided by the .NET Framework and the unmanaged native Windows code model. The information in this article applies to unmanaged Visual C++ code only.

SUMMARY
=======

In an MFC application, you can override existing interfaces in a class as well
as provide additional interfaces. Overriding an interface in this case is
synonymous with replacing an interface. The example in this article illustrates
how to override an interface in a class while preserving the original interface
implementation so that it can be delegated to by the new interface
implementation.

This article doesn't deal with overriding the IDispatch implementation as this is
a special case. The following article demonstrates how to override IDispatch in
MFC:

   Q140616 MFCDISP: Replacing MFC's IDispatch implementation


MORE INFORMATION
================

The following steps will override the IOleObject implementation for a default
OLE Control generated by the Control Wizard.

1. To add the declaration of the IOleObject implementation to the control, add
   the following code to the header file for the COleControl-derived class:

         // Interface Maps
         protected:
              // IOleObject
              BEGIN_INTERFACE_PART(MyOleObject, IOleObject)
                  INIT_INTERFACE_PART(CIOleOverCtrl, MyOleObject)
                  STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
                  STDMETHOD(GetClientSite)(LPOLECLIENTSITE*);
                  STDMETHOD(SetHostNames)(LPCOLESTR, LPCOLESTR);
                  STDMETHOD(Close)(DWORD);
                  STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
                  STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
                  STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
                  STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT*);
                  STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND,
                          LPCRECT);
                  STDMETHOD(EnumVerbs)(IEnumOLEVERB**);
                  STDMETHOD(Update)();
                  STDMETHOD(IsUpToDate)();
                  STDMETHOD(GetUserClassID)(CLSID*);
                  STDMETHOD(GetUserType)(DWORD, LPOLESTR*);
                  STDMETHOD(SetExtent)(DWORD, LPSIZEL);
                  STDMETHOD(GetExtent)(DWORD, LPSIZEL);
                  STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
                  STDMETHOD(Unadvise)(DWORD);
                  STDMETHOD(EnumAdvise)(LPENUMSTATDATA*);
                  STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
                  STDMETHOD(SetColorScheme)(LPLOGPALETTE);
              END_INTERFACE_PART(MyOleObject)

         DECLARE_INTERFACE_MAP();

   This adds a nested class XMyOleObject to your control class. Note that these
   macros declare interface methods including the IUnknown interface methods, so
   you must implement the IUnknown methods as well.

2. Add the IOleObject interface to the interface map for the control by adding
   an INTERFACE_PART macro to the implementation file for the control:

         BEGIN_INTERFACE_MAP(CIOleOverCtrl, COleControl)
            INTERFACE_PART(CIOleOverCtrl, IID_IOleObject, MyOleObject)
         END_INTERFACE_MAP()

   Replace CIOleOverCtrl with the name of your control and MyOleObject with the
   name you chose for the nested class that supports IOleObject.

3. Implement the interface methods you declared. Add the following code to the
   implementation file for the control:

         STDMETHODIMP_(ULONG) CIOleOverCtrl::XMyOleObject::AddRef()
         {
             METHOD_MANAGE_STATE(CIOleOverCtrl, MyOleObject)
             ASSERT_VALID(pThis);

             return pThis->m_xOleObject.AddRef();
         }

         STDMETHODIMP_(ULONG) CIOleOverCtrl::XMyOleObject::Release()
         {
             METHOD_MANAGE_STATE(CIOleOverCtrl, MyOleObject)
             ASSERT_VALID(pThis);

             return pThis->m_xOleObject.Release ();
         }

         STDMETHODIMP CIOleOverCtrl::XMyOleObject::QueryInterface(
             REFIID iid, LPVOID far* ppvObj)
         {
             METHOD_MANAGE_STATE(CIOleOverCtrl, MyOleObject)
             ASSERT_VALID(pThis);

             return pThis->m_xOleObject.QueryInterface ( iid,  ppvObj);
         }

         STDMETHODIMP
         CIOleOverCtrl::XMyOleObject::SetClientSite(LPOLECLIENTSITE
         pClientSite)
         {
             METHOD_MANAGE_STATE(CIOleOverCtrl, MyOleObject)
                ASSERT_VALID(pThis);

             return pThis->m_xOleObject.SetClientSite ( pClientSite );
         }
         ...

The rest of the methods follow the same pattern where CIOleOverCtrl is the name
of the control, XMyOleObject is the name of the nested class that supports
IOleObject, and m_xMyOleObject is calculated by removing the I from the
interface being supported and adding m_x.

Note that these methods simply pass the call on to the original IOleObject
implementation. However, this is not a requirement; you could add functionality
and delegate to the original implementation or not delegate at all.

REFERENCES
==========

Technical Notes #38 and #39.

Additional query words:

======================================================================
Keywords          : kbole kbActiveX kbCOMt kbCtrl kbMFC kbVC200 kbVC400 kbVC500 kbVC600 kbGrpDSMFCATL kbArchitecture 
Technology        : kbAudDeveloper kbMFC
Version           : :2.0,2.1,2.2,4.0,5.0,6.0
Issue type        : kbhowto

=============================================================================

THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.

Copyright Microsoft Corporation 2002.