---
layout: page
title: "Q149327: FIX: C2440 Expanding Template with a Pointer to a Nested Class"
permalink: /kb/149/Q149327/
---

## Q149327: FIX: C2440 Expanding Template with a Pointer to a Nested Class

{% raw %}

	Article: Q149327
	Product(s): Microsoft C Compiler
	Version(s): 
	Operating System(s): 
	Keyword(s): kbVC400bug kbVC410bug kbVC420bug kbVC500bug kbVC600fix
	Last Modified: 30-JUL-2001
	
	-------------------------------------------------------------------------------
	The information in this article applies to:
	
	- The C/C++ Compiler (CL.EXE), used with:
	   - Microsoft Visual C++, 32-bit Editions, versions 4.0, 4.1 
	   - Microsoft Visual C++, 32-bit Enterprise Edition, version 4.2 
	   - Microsoft Visual C++, 32-bit Professional Edition, version 4.2 
	   - Microsoft Visual C++, 32-bit Enterprise Edition, version 5.0 
	   - Microsoft Visual C++, 32-bit Professional Edition, version 5.0 
	-------------------------------------------------------------------------------
	
	SYMPTOMS
	========
	
	At the point where a class template is expanded using a pointer to a nested
	class, the compiler reports the following errors (generated by the sample code
	listed in this article):
	
	  [FileName](14) : error C2440: 'initializing' : cannot convert from 'class
	  A::B' to 'class A::B *' (new behavior; please see help)
	
	  [FileName](14) : error C2439: 't' : member could not be initialized
	
	Lines 13 and 14 in the sample code are:
	
	  template <class T> C<T>::C() : t(T())  // error
	     {
	
	RESOLUTION
	==========
	
	There are three possible workarounds to this problem. Each is stated here in
	terms of the sample code included in this article:
	
	- Remove t(T()) from the initializer list and add t = T(); to the body of the
	  constructor. This workaround assumes there is an operator= defined for class
	  T.
	
	- Change C<A::B *> c; to C<A::B&> c; or C<A::B> c:
	
	- Change the definitions of class A and class B to that B is no longer nested
	  in the definition of A.
	
	STATUS
	======
	
	Microsoft has confirmed this to be a bug in the Microsoft products listed at the
	beginning of this article.
	
	MORE INFORMATION
	================
	
	In this case, the problem is caused by the attempt to initialize the data member
	t.
	
	Sample Code
	-----------
	
	  /* Compile options needed: None */ 
	  template <class T> class C
	  {
	  public:
	    C();
	  private:
	    T t;
	  };
	
	  template <class T> C<T>::C() : t(T())  // error
	  {
	  }
	
	  class A
	  {
	  public:
	
	     class B
	     {
	     };
	
	  };
	
	  main()
	  {
	
	     C<A::B *> c;
	     return 0;
	
	  }
	
	Additional query words:
	
	======================================================================
	Keywords          : kbVC400bug kbVC410bug kbVC420bug kbVC500bug kbVC600fix 
	Technology        : kbVCsearch kbAudDeveloper kbCVCComp
	Issue type        : kbbug
	Solution Type     : kbfix
	
	=============================================================================
	

{% endraw %}
